// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'user_existace_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$UserExistenceState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() completed,
    required TResult Function() missing,
    required TResult Function() offline,
    required TResult Function() error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? completed,
    TResult Function()? missing,
    TResult Function()? offline,
    TResult Function()? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? completed,
    TResult Function()? missing,
    TResult Function()? offline,
    TResult Function()? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserExistenceLoading value) loading,
    required TResult Function(UserExistenceCompleted value) completed,
    required TResult Function(UserExistenceMissing value) missing,
    required TResult Function(UserExistenceOffline value) offline,
    required TResult Function(UserExistenceError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserExistenceLoading value)? loading,
    TResult Function(UserExistenceCompleted value)? completed,
    TResult Function(UserExistenceMissing value)? missing,
    TResult Function(UserExistenceOffline value)? offline,
    TResult Function(UserExistenceError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserExistenceLoading value)? loading,
    TResult Function(UserExistenceCompleted value)? completed,
    TResult Function(UserExistenceMissing value)? missing,
    TResult Function(UserExistenceOffline value)? offline,
    TResult Function(UserExistenceError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserExistenceStateCopyWith<$Res> {
  factory $UserExistenceStateCopyWith(
          UserExistenceState value, $Res Function(UserExistenceState) then) =
      _$UserExistenceStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserExistenceStateCopyWithImpl<$Res>
    implements $UserExistenceStateCopyWith<$Res> {
  _$UserExistenceStateCopyWithImpl(this._value, this._then);

  final UserExistenceState _value;
  // ignore: unused_field
  final $Res Function(UserExistenceState) _then;
}

/// @nodoc
abstract class _$$UserExistenceLoadingCopyWith<$Res> {
  factory _$$UserExistenceLoadingCopyWith(_$UserExistenceLoading value,
          $Res Function(_$UserExistenceLoading) then) =
      __$$UserExistenceLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserExistenceLoadingCopyWithImpl<$Res>
    extends _$UserExistenceStateCopyWithImpl<$Res>
    implements _$$UserExistenceLoadingCopyWith<$Res> {
  __$$UserExistenceLoadingCopyWithImpl(_$UserExistenceLoading _value,
      $Res Function(_$UserExistenceLoading) _then)
      : super(_value, (v) => _then(v as _$UserExistenceLoading));

  @override
  _$UserExistenceLoading get _value => super._value as _$UserExistenceLoading;
}

/// @nodoc

class _$UserExistenceLoading implements UserExistenceLoading {
  const _$UserExistenceLoading();

  @override
  String toString() {
    return 'UserExistenceState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserExistenceLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() completed,
    required TResult Function() missing,
    required TResult Function() offline,
    required TResult Function() error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? completed,
    TResult Function()? missing,
    TResult Function()? offline,
    TResult Function()? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? completed,
    TResult Function()? missing,
    TResult Function()? offline,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserExistenceLoading value) loading,
    required TResult Function(UserExistenceCompleted value) completed,
    required TResult Function(UserExistenceMissing value) missing,
    required TResult Function(UserExistenceOffline value) offline,
    required TResult Function(UserExistenceError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserExistenceLoading value)? loading,
    TResult Function(UserExistenceCompleted value)? completed,
    TResult Function(UserExistenceMissing value)? missing,
    TResult Function(UserExistenceOffline value)? offline,
    TResult Function(UserExistenceError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserExistenceLoading value)? loading,
    TResult Function(UserExistenceCompleted value)? completed,
    TResult Function(UserExistenceMissing value)? missing,
    TResult Function(UserExistenceOffline value)? offline,
    TResult Function(UserExistenceError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class UserExistenceLoading implements UserExistenceState {
  const factory UserExistenceLoading() = _$UserExistenceLoading;
}

/// @nodoc
abstract class _$$UserExistenceCompletedCopyWith<$Res> {
  factory _$$UserExistenceCompletedCopyWith(_$UserExistenceCompleted value,
          $Res Function(_$UserExistenceCompleted) then) =
      __$$UserExistenceCompletedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserExistenceCompletedCopyWithImpl<$Res>
    extends _$UserExistenceStateCopyWithImpl<$Res>
    implements _$$UserExistenceCompletedCopyWith<$Res> {
  __$$UserExistenceCompletedCopyWithImpl(_$UserExistenceCompleted _value,
      $Res Function(_$UserExistenceCompleted) _then)
      : super(_value, (v) => _then(v as _$UserExistenceCompleted));

  @override
  _$UserExistenceCompleted get _value =>
      super._value as _$UserExistenceCompleted;
}

/// @nodoc

class _$UserExistenceCompleted implements UserExistenceCompleted {
  const _$UserExistenceCompleted();

  @override
  String toString() {
    return 'UserExistenceState.completed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserExistenceCompleted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() completed,
    required TResult Function() missing,
    required TResult Function() offline,
    required TResult Function() error,
  }) {
    return completed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? completed,
    TResult Function()? missing,
    TResult Function()? offline,
    TResult Function()? error,
  }) {
    return completed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? completed,
    TResult Function()? missing,
    TResult Function()? offline,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserExistenceLoading value) loading,
    required TResult Function(UserExistenceCompleted value) completed,
    required TResult Function(UserExistenceMissing value) missing,
    required TResult Function(UserExistenceOffline value) offline,
    required TResult Function(UserExistenceError value) error,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserExistenceLoading value)? loading,
    TResult Function(UserExistenceCompleted value)? completed,
    TResult Function(UserExistenceMissing value)? missing,
    TResult Function(UserExistenceOffline value)? offline,
    TResult Function(UserExistenceError value)? error,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserExistenceLoading value)? loading,
    TResult Function(UserExistenceCompleted value)? completed,
    TResult Function(UserExistenceMissing value)? missing,
    TResult Function(UserExistenceOffline value)? offline,
    TResult Function(UserExistenceError value)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }
}

abstract class UserExistenceCompleted implements UserExistenceState {
  const factory UserExistenceCompleted() = _$UserExistenceCompleted;
}

/// @nodoc
abstract class _$$UserExistenceMissingCopyWith<$Res> {
  factory _$$UserExistenceMissingCopyWith(_$UserExistenceMissing value,
          $Res Function(_$UserExistenceMissing) then) =
      __$$UserExistenceMissingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserExistenceMissingCopyWithImpl<$Res>
    extends _$UserExistenceStateCopyWithImpl<$Res>
    implements _$$UserExistenceMissingCopyWith<$Res> {
  __$$UserExistenceMissingCopyWithImpl(_$UserExistenceMissing _value,
      $Res Function(_$UserExistenceMissing) _then)
      : super(_value, (v) => _then(v as _$UserExistenceMissing));

  @override
  _$UserExistenceMissing get _value => super._value as _$UserExistenceMissing;
}

/// @nodoc

class _$UserExistenceMissing implements UserExistenceMissing {
  const _$UserExistenceMissing();

  @override
  String toString() {
    return 'UserExistenceState.missing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserExistenceMissing);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() completed,
    required TResult Function() missing,
    required TResult Function() offline,
    required TResult Function() error,
  }) {
    return missing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? completed,
    TResult Function()? missing,
    TResult Function()? offline,
    TResult Function()? error,
  }) {
    return missing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? completed,
    TResult Function()? missing,
    TResult Function()? offline,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (missing != null) {
      return missing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserExistenceLoading value) loading,
    required TResult Function(UserExistenceCompleted value) completed,
    required TResult Function(UserExistenceMissing value) missing,
    required TResult Function(UserExistenceOffline value) offline,
    required TResult Function(UserExistenceError value) error,
  }) {
    return missing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserExistenceLoading value)? loading,
    TResult Function(UserExistenceCompleted value)? completed,
    TResult Function(UserExistenceMissing value)? missing,
    TResult Function(UserExistenceOffline value)? offline,
    TResult Function(UserExistenceError value)? error,
  }) {
    return missing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserExistenceLoading value)? loading,
    TResult Function(UserExistenceCompleted value)? completed,
    TResult Function(UserExistenceMissing value)? missing,
    TResult Function(UserExistenceOffline value)? offline,
    TResult Function(UserExistenceError value)? error,
    required TResult orElse(),
  }) {
    if (missing != null) {
      return missing(this);
    }
    return orElse();
  }
}

abstract class UserExistenceMissing implements UserExistenceState {
  const factory UserExistenceMissing() = _$UserExistenceMissing;
}

/// @nodoc
abstract class _$$UserExistenceOfflineCopyWith<$Res> {
  factory _$$UserExistenceOfflineCopyWith(_$UserExistenceOffline value,
          $Res Function(_$UserExistenceOffline) then) =
      __$$UserExistenceOfflineCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserExistenceOfflineCopyWithImpl<$Res>
    extends _$UserExistenceStateCopyWithImpl<$Res>
    implements _$$UserExistenceOfflineCopyWith<$Res> {
  __$$UserExistenceOfflineCopyWithImpl(_$UserExistenceOffline _value,
      $Res Function(_$UserExistenceOffline) _then)
      : super(_value, (v) => _then(v as _$UserExistenceOffline));

  @override
  _$UserExistenceOffline get _value => super._value as _$UserExistenceOffline;
}

/// @nodoc

class _$UserExistenceOffline implements UserExistenceOffline {
  const _$UserExistenceOffline();

  @override
  String toString() {
    return 'UserExistenceState.offline()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserExistenceOffline);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() completed,
    required TResult Function() missing,
    required TResult Function() offline,
    required TResult Function() error,
  }) {
    return offline();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? completed,
    TResult Function()? missing,
    TResult Function()? offline,
    TResult Function()? error,
  }) {
    return offline?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? completed,
    TResult Function()? missing,
    TResult Function()? offline,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (offline != null) {
      return offline();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserExistenceLoading value) loading,
    required TResult Function(UserExistenceCompleted value) completed,
    required TResult Function(UserExistenceMissing value) missing,
    required TResult Function(UserExistenceOffline value) offline,
    required TResult Function(UserExistenceError value) error,
  }) {
    return offline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserExistenceLoading value)? loading,
    TResult Function(UserExistenceCompleted value)? completed,
    TResult Function(UserExistenceMissing value)? missing,
    TResult Function(UserExistenceOffline value)? offline,
    TResult Function(UserExistenceError value)? error,
  }) {
    return offline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserExistenceLoading value)? loading,
    TResult Function(UserExistenceCompleted value)? completed,
    TResult Function(UserExistenceMissing value)? missing,
    TResult Function(UserExistenceOffline value)? offline,
    TResult Function(UserExistenceError value)? error,
    required TResult orElse(),
  }) {
    if (offline != null) {
      return offline(this);
    }
    return orElse();
  }
}

abstract class UserExistenceOffline implements UserExistenceState {
  const factory UserExistenceOffline() = _$UserExistenceOffline;
}

/// @nodoc
abstract class _$$UserExistenceErrorCopyWith<$Res> {
  factory _$$UserExistenceErrorCopyWith(_$UserExistenceError value,
          $Res Function(_$UserExistenceError) then) =
      __$$UserExistenceErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserExistenceErrorCopyWithImpl<$Res>
    extends _$UserExistenceStateCopyWithImpl<$Res>
    implements _$$UserExistenceErrorCopyWith<$Res> {
  __$$UserExistenceErrorCopyWithImpl(
      _$UserExistenceError _value, $Res Function(_$UserExistenceError) _then)
      : super(_value, (v) => _then(v as _$UserExistenceError));

  @override
  _$UserExistenceError get _value => super._value as _$UserExistenceError;
}

/// @nodoc

class _$UserExistenceError implements UserExistenceError {
  const _$UserExistenceError();

  @override
  String toString() {
    return 'UserExistenceState.error()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserExistenceError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() completed,
    required TResult Function() missing,
    required TResult Function() offline,
    required TResult Function() error,
  }) {
    return error();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? completed,
    TResult Function()? missing,
    TResult Function()? offline,
    TResult Function()? error,
  }) {
    return error?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? completed,
    TResult Function()? missing,
    TResult Function()? offline,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserExistenceLoading value) loading,
    required TResult Function(UserExistenceCompleted value) completed,
    required TResult Function(UserExistenceMissing value) missing,
    required TResult Function(UserExistenceOffline value) offline,
    required TResult Function(UserExistenceError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UserExistenceLoading value)? loading,
    TResult Function(UserExistenceCompleted value)? completed,
    TResult Function(UserExistenceMissing value)? missing,
    TResult Function(UserExistenceOffline value)? offline,
    TResult Function(UserExistenceError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserExistenceLoading value)? loading,
    TResult Function(UserExistenceCompleted value)? completed,
    TResult Function(UserExistenceMissing value)? missing,
    TResult Function(UserExistenceOffline value)? offline,
    TResult Function(UserExistenceError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class UserExistenceError implements UserExistenceState {
  const factory UserExistenceError() = _$UserExistenceError;
}
