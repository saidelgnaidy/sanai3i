// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'failuer.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$Failuer {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() offline,
    required TResult Function() server,
    required TResult Function() emptyCache,
    required TResult Function() wrongPhone,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? offline,
    TResult Function()? server,
    TResult Function()? emptyCache,
    TResult Function()? wrongPhone,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? offline,
    TResult Function()? server,
    TResult Function()? emptyCache,
    TResult Function()? wrongPhone,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OfflineFailuer value) offline,
    required TResult Function(ServerFailuer value) server,
    required TResult Function(EmptyCacheFailuer value) emptyCache,
    required TResult Function(WrongPphoneFailuer value) wrongPhone,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OfflineFailuer value)? offline,
    TResult Function(ServerFailuer value)? server,
    TResult Function(EmptyCacheFailuer value)? emptyCache,
    TResult Function(WrongPphoneFailuer value)? wrongPhone,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OfflineFailuer value)? offline,
    TResult Function(ServerFailuer value)? server,
    TResult Function(EmptyCacheFailuer value)? emptyCache,
    TResult Function(WrongPphoneFailuer value)? wrongPhone,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FailuerCopyWith<$Res> {
  factory $FailuerCopyWith(Failuer value, $Res Function(Failuer) then) =
      _$FailuerCopyWithImpl<$Res>;
}

/// @nodoc
class _$FailuerCopyWithImpl<$Res> implements $FailuerCopyWith<$Res> {
  _$FailuerCopyWithImpl(this._value, this._then);

  final Failuer _value;
  // ignore: unused_field
  final $Res Function(Failuer) _then;
}

/// @nodoc
abstract class _$$OfflineFailuerCopyWith<$Res> {
  factory _$$OfflineFailuerCopyWith(
          _$OfflineFailuer value, $Res Function(_$OfflineFailuer) then) =
      __$$OfflineFailuerCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OfflineFailuerCopyWithImpl<$Res> extends _$FailuerCopyWithImpl<$Res>
    implements _$$OfflineFailuerCopyWith<$Res> {
  __$$OfflineFailuerCopyWithImpl(
      _$OfflineFailuer _value, $Res Function(_$OfflineFailuer) _then)
      : super(_value, (v) => _then(v as _$OfflineFailuer));

  @override
  _$OfflineFailuer get _value => super._value as _$OfflineFailuer;
}

/// @nodoc

class _$OfflineFailuer implements OfflineFailuer {
  const _$OfflineFailuer();

  @override
  String toString() {
    return 'Failuer.offline()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OfflineFailuer);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() offline,
    required TResult Function() server,
    required TResult Function() emptyCache,
    required TResult Function() wrongPhone,
  }) {
    return offline();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? offline,
    TResult Function()? server,
    TResult Function()? emptyCache,
    TResult Function()? wrongPhone,
  }) {
    return offline?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? offline,
    TResult Function()? server,
    TResult Function()? emptyCache,
    TResult Function()? wrongPhone,
    required TResult orElse(),
  }) {
    if (offline != null) {
      return offline();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OfflineFailuer value) offline,
    required TResult Function(ServerFailuer value) server,
    required TResult Function(EmptyCacheFailuer value) emptyCache,
    required TResult Function(WrongPphoneFailuer value) wrongPhone,
  }) {
    return offline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OfflineFailuer value)? offline,
    TResult Function(ServerFailuer value)? server,
    TResult Function(EmptyCacheFailuer value)? emptyCache,
    TResult Function(WrongPphoneFailuer value)? wrongPhone,
  }) {
    return offline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OfflineFailuer value)? offline,
    TResult Function(ServerFailuer value)? server,
    TResult Function(EmptyCacheFailuer value)? emptyCache,
    TResult Function(WrongPphoneFailuer value)? wrongPhone,
    required TResult orElse(),
  }) {
    if (offline != null) {
      return offline(this);
    }
    return orElse();
  }
}

abstract class OfflineFailuer implements Failuer {
  const factory OfflineFailuer() = _$OfflineFailuer;
}

/// @nodoc
abstract class _$$ServerFailuerCopyWith<$Res> {
  factory _$$ServerFailuerCopyWith(
          _$ServerFailuer value, $Res Function(_$ServerFailuer) then) =
      __$$ServerFailuerCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServerFailuerCopyWithImpl<$Res> extends _$FailuerCopyWithImpl<$Res>
    implements _$$ServerFailuerCopyWith<$Res> {
  __$$ServerFailuerCopyWithImpl(
      _$ServerFailuer _value, $Res Function(_$ServerFailuer) _then)
      : super(_value, (v) => _then(v as _$ServerFailuer));

  @override
  _$ServerFailuer get _value => super._value as _$ServerFailuer;
}

/// @nodoc

class _$ServerFailuer implements ServerFailuer {
  const _$ServerFailuer();

  @override
  String toString() {
    return 'Failuer.server()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServerFailuer);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() offline,
    required TResult Function() server,
    required TResult Function() emptyCache,
    required TResult Function() wrongPhone,
  }) {
    return server();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? offline,
    TResult Function()? server,
    TResult Function()? emptyCache,
    TResult Function()? wrongPhone,
  }) {
    return server?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? offline,
    TResult Function()? server,
    TResult Function()? emptyCache,
    TResult Function()? wrongPhone,
    required TResult orElse(),
  }) {
    if (server != null) {
      return server();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OfflineFailuer value) offline,
    required TResult Function(ServerFailuer value) server,
    required TResult Function(EmptyCacheFailuer value) emptyCache,
    required TResult Function(WrongPphoneFailuer value) wrongPhone,
  }) {
    return server(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OfflineFailuer value)? offline,
    TResult Function(ServerFailuer value)? server,
    TResult Function(EmptyCacheFailuer value)? emptyCache,
    TResult Function(WrongPphoneFailuer value)? wrongPhone,
  }) {
    return server?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OfflineFailuer value)? offline,
    TResult Function(ServerFailuer value)? server,
    TResult Function(EmptyCacheFailuer value)? emptyCache,
    TResult Function(WrongPphoneFailuer value)? wrongPhone,
    required TResult orElse(),
  }) {
    if (server != null) {
      return server(this);
    }
    return orElse();
  }
}

abstract class ServerFailuer implements Failuer {
  const factory ServerFailuer() = _$ServerFailuer;
}

/// @nodoc
abstract class _$$EmptyCacheFailuerCopyWith<$Res> {
  factory _$$EmptyCacheFailuerCopyWith(
          _$EmptyCacheFailuer value, $Res Function(_$EmptyCacheFailuer) then) =
      __$$EmptyCacheFailuerCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmptyCacheFailuerCopyWithImpl<$Res>
    extends _$FailuerCopyWithImpl<$Res>
    implements _$$EmptyCacheFailuerCopyWith<$Res> {
  __$$EmptyCacheFailuerCopyWithImpl(
      _$EmptyCacheFailuer _value, $Res Function(_$EmptyCacheFailuer) _then)
      : super(_value, (v) => _then(v as _$EmptyCacheFailuer));

  @override
  _$EmptyCacheFailuer get _value => super._value as _$EmptyCacheFailuer;
}

/// @nodoc

class _$EmptyCacheFailuer implements EmptyCacheFailuer {
  const _$EmptyCacheFailuer();

  @override
  String toString() {
    return 'Failuer.emptyCache()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EmptyCacheFailuer);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() offline,
    required TResult Function() server,
    required TResult Function() emptyCache,
    required TResult Function() wrongPhone,
  }) {
    return emptyCache();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? offline,
    TResult Function()? server,
    TResult Function()? emptyCache,
    TResult Function()? wrongPhone,
  }) {
    return emptyCache?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? offline,
    TResult Function()? server,
    TResult Function()? emptyCache,
    TResult Function()? wrongPhone,
    required TResult orElse(),
  }) {
    if (emptyCache != null) {
      return emptyCache();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OfflineFailuer value) offline,
    required TResult Function(ServerFailuer value) server,
    required TResult Function(EmptyCacheFailuer value) emptyCache,
    required TResult Function(WrongPphoneFailuer value) wrongPhone,
  }) {
    return emptyCache(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OfflineFailuer value)? offline,
    TResult Function(ServerFailuer value)? server,
    TResult Function(EmptyCacheFailuer value)? emptyCache,
    TResult Function(WrongPphoneFailuer value)? wrongPhone,
  }) {
    return emptyCache?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OfflineFailuer value)? offline,
    TResult Function(ServerFailuer value)? server,
    TResult Function(EmptyCacheFailuer value)? emptyCache,
    TResult Function(WrongPphoneFailuer value)? wrongPhone,
    required TResult orElse(),
  }) {
    if (emptyCache != null) {
      return emptyCache(this);
    }
    return orElse();
  }
}

abstract class EmptyCacheFailuer implements Failuer {
  const factory EmptyCacheFailuer() = _$EmptyCacheFailuer;
}

/// @nodoc
abstract class _$$WrongPphoneFailuerCopyWith<$Res> {
  factory _$$WrongPphoneFailuerCopyWith(_$WrongPphoneFailuer value,
          $Res Function(_$WrongPphoneFailuer) then) =
      __$$WrongPphoneFailuerCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WrongPphoneFailuerCopyWithImpl<$Res>
    extends _$FailuerCopyWithImpl<$Res>
    implements _$$WrongPphoneFailuerCopyWith<$Res> {
  __$$WrongPphoneFailuerCopyWithImpl(
      _$WrongPphoneFailuer _value, $Res Function(_$WrongPphoneFailuer) _then)
      : super(_value, (v) => _then(v as _$WrongPphoneFailuer));

  @override
  _$WrongPphoneFailuer get _value => super._value as _$WrongPphoneFailuer;
}

/// @nodoc

class _$WrongPphoneFailuer implements WrongPphoneFailuer {
  const _$WrongPphoneFailuer();

  @override
  String toString() {
    return 'Failuer.wrongPhone()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WrongPphoneFailuer);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() offline,
    required TResult Function() server,
    required TResult Function() emptyCache,
    required TResult Function() wrongPhone,
  }) {
    return wrongPhone();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? offline,
    TResult Function()? server,
    TResult Function()? emptyCache,
    TResult Function()? wrongPhone,
  }) {
    return wrongPhone?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? offline,
    TResult Function()? server,
    TResult Function()? emptyCache,
    TResult Function()? wrongPhone,
    required TResult orElse(),
  }) {
    if (wrongPhone != null) {
      return wrongPhone();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OfflineFailuer value) offline,
    required TResult Function(ServerFailuer value) server,
    required TResult Function(EmptyCacheFailuer value) emptyCache,
    required TResult Function(WrongPphoneFailuer value) wrongPhone,
  }) {
    return wrongPhone(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(OfflineFailuer value)? offline,
    TResult Function(ServerFailuer value)? server,
    TResult Function(EmptyCacheFailuer value)? emptyCache,
    TResult Function(WrongPphoneFailuer value)? wrongPhone,
  }) {
    return wrongPhone?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OfflineFailuer value)? offline,
    TResult Function(ServerFailuer value)? server,
    TResult Function(EmptyCacheFailuer value)? emptyCache,
    TResult Function(WrongPphoneFailuer value)? wrongPhone,
    required TResult orElse(),
  }) {
    if (wrongPhone != null) {
      return wrongPhone(this);
    }
    return orElse();
  }
}

abstract class WrongPphoneFailuer implements Failuer {
  const factory WrongPphoneFailuer() = _$WrongPphoneFailuer;
}
